= A – Frog 1
Educational DP Contest – AtCoder

:problem-number: A
:time-limit: 2 sec
:memory-limit: 1024 MiB
:score: 100 points
:stem: latexmath
:plantuml-format: svg
:plantuml-embed: true
:docinfo: shared


== Problem Statement

There are stem:[N] stones, numbered stem:[1,2,…,N]. For each stem:[i (1≤i≤N)], the height of Stone stem:[i] is
stem:[h_i].

There is a frog who is initially on Stone stem:[1]. He will repeat the following action some number of times to reach
 Stone stem:[N]:

If the frog is currently on Stone stem:[i], jump to Stone stem:[i+1] or Stone stem:[i+2]. Here, a cost of stem:[∣h_i
− h_j ∣] is incurred, where stem:[j] is the stone to land on. Find the minimum possible total cost incurred before
the frog reaches Stone stem:[N].

== Constraints

* All values in input are integers.
* stem:[2≤N≤10^5]
* stem:[1≤h_i≤10^4]

== Input
Input is given from Standard Input in the following format:

[example]
====
stem:[N]

stem:[h_1 \ h_2 \ ... \ h_N]
====

== Output
Print the minimum possible total cost incurred.

== Thinking out loud

=== Sample Input 1
[example]
====
4

10 30 40 20
====

=== Sample Output 1
[example]
====
30
====
If we follow the path 1 -> 2 -> 4, the total cost incurred would be stem:[| 10 - 30 | + | 30 - 20 | = 30].

[open]
--
[plantuml]
....

(10) as _0
(30) as _1
(40) as _2
(40) as _3
(20) as _4
(20) as _5
(20) as _6

_0 --> _1  /'10 to 30'/
_0 --> _2  /'10 to 40'/
_1 --> _3  /'30 to 40'/
_1 --> _4  /'30 to 20'/

_2 --> _5  /'40 to 20'/
_3 -down--> _6  /'40 to 20'/
_6 .....> _3 : 0

_4 ...> _1 : 0
_5 ...> _2 : 0
_3 ...> _1 : 20
_2 ...> _0 : 20
_1 ...> _0 : 20

note right of _6
    leftTree = NULL
    rightTree = NULL
    leftTreeCost = 0 = leftTree != NULL ? (abs(20 - leftTree.value) + recur(leftTree)) : 0
    rightTreeCost = 0 = rightTree != NULL ? (abs(20 - rightTree.value) + recur(rightTree)) : 0
    minCost = min(leftTreeCost, rightTreeCost) = min(0, 0) = 0
end note

note right of _4
    leftTree = NULL
    rightTree = NULL
    leftTreeCost = 0 = leftTree != NULL ? (abs(20 - leftTree.value) + recur(leftTree)) : 0
    rightTreeCost = 0 = rightTree != NULL ? (abs(20 - rightTree.value) + recur(rightTree)) : 0
    minCost = min(leftTreeCost, rightTreeCost) = min(0, 0) = 0
end note

note right of _5
    leftTree = NULL
    rightTree = NULL
    leftTreeCost = 0 = leftTree != NULL ? (abs(20 - leftTree.value) + recur(leftTree)) : 0
    rightTreeCost = 0 = rightTree != NULL ? (abs(20 - rightTree.value) + recur(rightTree)) : 0
    minCost = min(leftTreeCost, rightTreeCost) = min(0, 0) = 0
end note


note right of _3
    leftTree = {value:20}
    rightTree = NULL
    leftTreeCost = 20 = leftTree != NULL ? (abs(40 - leftTree.value) + recur(leftTree)) : 0
    rightTreeCost = 0 = rightTree != NULL ? (abs(40 - rightTree.value) + recur(rightTree)) : 0
    minCost = min(leftTreeCost, rightTreeCost) = min(20, 0) = 20
end note

note right of _2
    leftTree = {value:20}
    rightTree = NULL
    leftTreeCost = 20 = leftTree != NULL ? (abs(40 - leftTree.value) + recur(leftTree)) : 0
    rightTreeCost = 0 = rightTree != NULL ? (abs(40 - rightTree.value) + recur(rightTree)) : 0
    minCost = min(leftTreeCost, rightTreeCost) = min(20, 0) = 20
end note

note right of _1
    leftTree = {value:40}
    rightTree = {value:20}
    leftTreeCost = 30 = leftTree != NULL ? (abs(30 - leftTree.value) + recur(leftTree)) : 0
    rightTreeCost = 10 = rightTree != NULL ? (abs(30 - rightTree.value) + recur(rightTree)) : 0
    minCost = min(leftTreeCost, rightTreeCost) = min(30, 10) = 10
end note

note right of _0
    leftTree = {value:20}
    rightTree = {value:40}
    leftTreeCost = 30 = leftTree != NULL ? (abs(10 - leftTree.value) + recur(leftTree)) : 0
    rightTreeCost = 50 = rightTree != NULL ? (abs(10 - rightTree.value) + recur(rightTree)) : 0
    minCost = min(leftTreeCost, rightTreeCost) = min(30, 50) = 30
end note
....
--


=== Sample Input 2
[example]
====
2

10 10
====

=== Sample Output 2
[example]
====
0
====
If we follow the path 1 -> 2, the total cost incurred would be stem:[| 10 - 10 | = 0].

[open]
--
[plantuml]
....

(10) as _0
(10) as _1

_0 --> _1  /'10 to 10'/

_1 ...> _0 : 0

note right of _1
    leftTree = NULL
    rightTree = NULL
    leftTreeCost = 0 = leftTree != NULL ? (abs(10 - leftTree.value) + recur(leftTree)) : 0
    rightTreeCost = 0 = rightTree != NULL ? (abs(10 - rightTree.value) + recur(rightTree)) : 0
    minCost = min(leftTreeCost, rightTreeCost) = min(0, 0) = 0
end note

note right of _0
    leftTree = {value:10}
    rightTree = NULL
    leftTreeCost = 0 = leftTree != NULL ? (abs(10 - leftTree.value) + recur(leftTree)) : 0
    rightTreeCost = 0 = rightTree != NULL ? (abs(10 - rightTree.value) + recur(rightTree)) : 0
    minCost = min(leftTreeCost, rightTreeCost) = min(0, 0) = 0
end note
....
--